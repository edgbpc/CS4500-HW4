'''
Eric Goodwin
09-17-2018
Python 3.7.0
PyCharm IDE
CS 4500 Introduction to the Software Profession

External File used - HWinfile.txt.  Must be supplied to run sim
Program creates this file with output data.  data is same as what
is displayed on the screen running of the program.



Resources Used:
https://docs.python.org/3/library
https://thispointer.com/python-how-to-check-if-an-item-exists-in-list-search-by-value-or-condition/
https://www.geeksforgeeks.org/sum-function-python/
https://www.tutorialspoint.com/python/list_max.htm
http://treyhunner.com/2016/04/how-to-loop-with-indexes-in-python/
https://stackoverflow.com/questions/493386/how-to-print-without-newline-or-space
https://stackoverflow.com/questions/10660435/pythonic-way-to-create-a-long-multi-line-string
https://www.programiz.com/python-programming/methods/list/clear
https://www.tutorialspoint.com/python/list_min.htm
https://coolpythoncodes.com/python-turtle/
https://cs.nyu.edu/courses/spring13/CSCI-UA.0002-007/CSCI_UA-02_Day21.pdf



Requirements (from HW2 Specification):
Simulate dice roll to determine direction - DONE
Account for invalid moves as a move as if jumping in place - DONE
Map moves to dice result - DONE
Encode movements on tuple - DONE
Print results to Screen - DONE
Print results to output file - DONE
Format out of output line - EX: 5, 4, 5, 6, 7.  Period signifies end of the line - DONE
Calculate statistics - total moves, average dots on a node, which node has max dots - DONE

Note - this version of the pyramid game is an extension of HW2
Keeping code from HW2 intact in order to test against same dice rolls for autogenerated nodes



Design:
Use a list of tuples to represent each location on the pyramid.  Each location to be encoded with data for number
of visits (dots) as well as valid moves. Invalid moves will be marked as None in the tuple.
use a variable, currentlocation, to hold where the player is currently at.  Starts at one.
Use if check to see if a move is valid
if move is valid, update currentlocation to the new location and record a visit.
if the move is not valid, currentlocation remains the same and update that location with a new visit
maintain another list of how often a location is visited.
game continues until a 0 is no longer detected in the tracker list.
one the game ends, compute statistics and display.

made a couple of design decisions-
I count the initial start of the game as a visit
I also added a pause in the execution so the use can "see" the locations being added to the visit list

Use git for version control.

New Features for HW3:
User can specify a number of leves to the pyramid between 2 and 25 levels. - DONE
Program checks for valid input and if incorrect, prints error message and reprompts.  repeats until valid input given -DONE
User can specify number of times to run the simulation between 10 and 50. - DPNE
Program checks for valid input  and if incorrect, prints error message and reprompts. repeats until valid input given - DONE
add total sim statistics - DONE

add feature to turn off on screen reporting of nodes visited -DONE

New Features for HW4:
Add graphical representation of pyramid - DONE
Add read in from file - DONE
Add repeat of sim to include generation of new board each run - DONE
Add table report - DONE


'''

# for the random number generator
import random
# for graphics suite
import turtle

# program creates this file if not already created
# outputFile = open("HW4goodwinOutfile.txt", "w")


introMessage = """Dice Rolling Simulation - 
Program runs 5 simulations.
The game consists of a pyramid of nodes.
A 4 sided die is rolled that indicates the direction to try to move.  
First simulation is always 6 levels and runs one time.  A graphical representation will be displayed.
Yellow indicates the current, active node.
As visits increase, nodes continually turn a darker shade of red.
Game continues until all nodes a visited and then displays game statistics.
The remaining simulations vary in level and times ran controlled by an input file.
Once all sims are complete, a table will display for statistics for those 4 games.

"""

print(introMessage + "\n")
# outputFile.write(introMessage + "\n\n")

# next section continually prompts until user selects yes or no for verbose mode.  verbose mode will show all
# visited location.  input is made not cast sensitive by using .lower method
# once valid entry is received, break from the while loop and proceed
# verbose mode off prevents display visited nodes from both screen and output file.  clarified in class
# option to turn off and on verbose disabled for this version of the assignment.  verbose always off
# verboseModeAnswerNotValid = True
verbose = False
'''
while verboseModeAnswerNotValid:
    verboseMode = input("Display all visited nodes (yes/no)?")
    verboseMode = verboseMode.lower()

    if verboseMode == 'yes':
        verbose = True
        verboseModeAnswerNotValid = False
        break
    if verboseMode == 'no':
        verbose = False
        verboseModeAnswerNotValid = False
        break
    if verboseMode is not {'yes', 'no'}: # if user input is not part of this set, loop while loop repeats until selected
        verboseModeAnswerNotValid = True
'''

# follow section purpose is to obtain number of levels from the user.
# commenting out selection of levels and times ran.  for HW4 controlled by input file
'''
# this code was part of HW3. disabled for this assignment
numberOfLevelsIsNotValid = True  # controls while loop.  must become false to break the loop
numLevels = 2  # declare number of levels.  minimum is 2 levels

# this while loop continues until a valid int in range of 2 to 25 is received.
while numberOfLevelsIsNotValid:
    numLevels = input("Enter integer between 2 and 25 for number of levels")

    # Check if input is a valid int
    if numLevels.isdigit():
        # check if the int is in the range of 2 to 25
        if int(numLevels) in range(2, 26):
            numberOfLevelsIsNotValid = False
        else:
            print("Invalid number of levels")
            numberOfLevelsIsNotValid = True
    else:
        print("Integer not entered.")
        numberOfLevelsIsNotValid = True

print("You entered " + numLevels + " levels for the pyramid")

numberOfTimesSimRanIsNotValid = True  # controls the while loop.  must become false to break the loop
numTimesRan = 10  # declare number of times sim is ran.  default is 10

while numberOfTimesSimRanIsNotValid:
    numTimesRan = input("Enter number of times to run the simulation between 10 and 50:")

    # Check if input is a valid int
    if numTimesRan.isdigit():
        #check if the int is in the range of 10 to 50
        if int(numTimesRan) in range(10, 51):
            numberOfTimesSimRanIsNotValid = False
        else:
            print("Invalid number of times")
            numberOfTimesSimRanIsNotValid = True

    else:
        print("Integer not entered.")
        numberOfTimesSimRanIsNotValid = True

# print("You entered " + numTimesRan + " to run the sim")
'''


# get the data from the input file that controls passes 2 through 5 of the game
readInFile = open("HWinfile.txt", "r")
parametersFromFile = readInFile.readlines()
# build the list of data needed to determine levels of the pyramid and number of times that game is ran
# first data pair is always 6, 1 for graphical representation..
# next pairs are from the input file

gameData = [6, 1]
for index in range(len(parametersFromFile)):
    tempData = parametersFromFile[index][1:-2].split(', ')
    gameData.append(int(tempData[0]))
    gameData.append(int(tempData[1]))

# close Read in file
readInFile.close()
# print(gameData)

# firstGame is used a flag. controls of the colorNode function is called.  Only calls on first run of the sim
firstGame = True

# colorSelector selects color based on numVisits.  gets darker the move visits to a node
# -1 is used a sentry to indicate the active node
def colorSelector(numVisits):
    # using -1 as a sentry to indicate current node
    # otherwise numVisits = number of times a node has been visited to determine color
    if numVisits == -1:
        return '#FFFF00'
    if numVisits == 0:
        return '#FFFFFF'
    if numVisits <= 5:
        return '#FF0000'
    if 6 <= numVisits <= 10:
        return '#800000'
    if numVisits > 10:
        return '#5D0000'


# colorNode redraws the triangle as the game moves to a new node.  Calls colorSelector to determine color
# when a node in a specific row is selected, turtle moves to beginning of the row and moves forward to the start of
# triangle that represents that node and redraws the triangle.
def colorNode(currentLocation):
    # row 1
    if currentLocation == 1:
        # change color of triangle 1
        rowOneTriangles.penup()
        rowOneTriangles.home()
        rowOneTriangles.goto(-175, 215)
        rowOneTriangles.left(60)
        # rowOneTriangles.forward(250)
        rowOneTriangles.fillcolor(colorSelector(numVisits))
        rowOneTriangles.begin_fill()
        rowOneTriangles.pendown()
        rowOneTriangles.right(60)
        rowOneTriangles.forward(50)
        rowOneTriangles.left(120)
        rowOneTriangles.forward(50)
        rowOneTriangles.left(120)
        rowOneTriangles.forward(50)
        rowOneTriangles.end_fill()
    # row 2

    if 2 <= currentLocation <= 3:
        rowTwoTriangles.penup()
        rowTwoTriangles.home()
        rowTwoTriangles.goto(-200, 173)
        rowTwoTriangles.left(60)
        # rowOneTriangles.forward(250)
        rowTwoTriangles.fillcolor(colorSelector(numVisits))
        rowTwoTriangles.begin_fill()
        rowTwoTriangles.pendown()
        rowTwoTriangles.right(60)

        if currentLocation == 2:
            rowTwoTriangles.forward(50)

        if currentLocation == 3:
            rowTwoTriangles.forward(100)

        rowTwoTriangles.left(120)
        rowTwoTriangles.forward(50)
        rowTwoTriangles.left(120)
        rowTwoTriangles.forward(50)
        rowTwoTriangles.end_fill()
        rowTwoTriangles.penup()

    # row 3
    if 4 <= currentLocation <= 6:
        rowThreeTriangles.penup()
        rowThreeTriangles.home()
        rowThreeTriangles.goto(-225, 130)
        rowThreeTriangles.left(60)
        # rowOneTriangles.forward(250)
        rowThreeTriangles.fillcolor(colorSelector(numVisits))
        rowThreeTriangles.begin_fill()
        rowThreeTriangles.pendown()
        rowThreeTriangles.right(60)

        if currentLocation == 4:
            rowThreeTriangles.forward(50)

        if currentLocation == 5:
            rowThreeTriangles.forward(100)

        if currentLocation == 6:
            rowThreeTriangles.forward(150)

        rowThreeTriangles.left(120)
        rowThreeTriangles.forward(50)
        rowThreeTriangles.left(120)
        rowThreeTriangles.forward(50)
        rowThreeTriangles.end_fill()

    # row 4
    if 7 <= currentLocation <= 10:
        rowFourTriangles.penup()
        rowFourTriangles.home()
        rowFourTriangles.goto(-250, 88)
        rowFourTriangles.left(60)
        # rowOneTriangles.forward(250)
        rowFourTriangles.fillcolor(colorSelector(numVisits))
        rowFourTriangles.begin_fill()
        rowFourTriangles.pendown()
        rowFourTriangles.right(60)

        if currentLocation == 7:
            rowFourTriangles.forward(50)
        if currentLocation == 8:
            rowFourTriangles.forward(100)
        if currentLocation == 9:
            rowFourTriangles.forward(150)
        if currentLocation == 10:
            rowFourTriangles.forward(200)

        rowFourTriangles.left(120)
        rowFourTriangles.forward(50)
        rowFourTriangles.left(120)
        rowFourTriangles.forward(50)
        rowFourTriangles.end_fill()

    # row 5
    if 11 <= currentLocation <= 15:
        rowFiveTriangles.penup()
        rowFiveTriangles.home()
        rowFiveTriangles.goto(-275, 44)
        rowFiveTriangles.left(60)
        # rowOneTriangles.forward(250)
        rowFiveTriangles.fillcolor(colorSelector(numVisits))
        rowFiveTriangles.begin_fill()
        rowFiveTriangles.pendown()
        rowFiveTriangles.right(60)

        if currentLocation == 11:
            rowFiveTriangles.forward(50)
        if currentLocation == 12:
            rowFiveTriangles.forward(100)
        if currentLocation == 13:
            rowFiveTriangles.forward(150)
        if currentLocation == 14:
            rowFiveTriangles.forward(200)
        if currentLocation == 15:
            rowFiveTriangles.forward(250)

        rowFiveTriangles.left(120)
        rowFiveTriangles.forward(50)
        rowFiveTriangles.left(120)
        rowFiveTriangles.forward(50)
        rowFiveTriangles.end_fill()

    # row 6
    if 16 <= currentLocation <= 21:
        rowSixTriangles.penup()
        rowSixTriangles.home()
        rowSixTriangles.goto(-300, 0)
        rowSixTriangles.left(60)
        # rowOneTriangles.forward(250)
        rowSixTriangles.fillcolor(colorSelector(numVisits))
        rowSixTriangles.begin_fill()
        rowSixTriangles.pendown()
        rowSixTriangles.right(60)

        if currentLocation == 16:
            rowSixTriangles.forward(50)
        if currentLocation == 17:
            rowSixTriangles.forward(100)
        if currentLocation == 18:
            rowSixTriangles.forward(150)
        if currentLocation == 19:
            rowSixTriangles.forward(200)
        if currentLocation == 20:
            rowSixTriangles.forward(250)
        if currentLocation == 21:
            rowSixTriangles.forward(300)

        rowSixTriangles.left(120)
        rowSixTriangles.forward(50)
        rowSixTriangles.left(120)
        rowSixTriangles.forward(50)
        rowSixTriangles.end_fill()


# draw the background of the gameboard
background = turtle.Turtle()
background.hideturtle()
background.speed(0)
background.fillcolor('black')
background.begin_fill()
background.penup()
background.goto(-300, 0)
background.pendown()
background.forward(300)
background.left(120)
background.forward(300)
background.left(120)
background.forward(300)
background.end_fill()


# draw each row of the game board, starts in row 6 and moves progress to row 1
rowSixTriangles = turtle.Turtle()
rowSixTriangles.hideturtle()
rowSixTriangles.speed(0)
rowSixTriangles.fillcolor(colorSelector(0))
rowSixTriangles.begin_fill()
rowSixTriangles.penup()
rowSixTriangles.goto(-300, 0)
rowSixTriangles.pendown()
for x in range(1, 7):
    rowSixTriangles.forward(50)
    rowSixTriangles.left(120)
    rowSixTriangles.forward(50)
    rowSixTriangles.left(120)
    rowSixTriangles.penup()
    rowSixTriangles.forward(50)
    rowSixTriangles.left(120)
    rowSixTriangles.forward(50)
    rowSixTriangles.pendown()
rowSixTriangles.end_fill()
rowSixTriangles.penup()

rowFiveTriangles = turtle.Turtle()
rowFiveTriangles.hideturtle()
rowFiveTriangles.speed(0)
rowFiveTriangles.fillcolor(colorSelector(0))
rowFiveTriangles.penup()
rowFiveTriangles.goto(-300, 0)
rowFiveTriangles.left(60)
rowFiveTriangles.forward(50)
rowFiveTriangles.right(60)
rowFiveTriangles.pendown()
rowFiveTriangles.begin_fill()
for x in range(1, 6):
    rowFiveTriangles.forward(50)
    rowFiveTriangles.left(120)
    rowFiveTriangles.forward(50)
    rowFiveTriangles.left(120)
    rowFiveTriangles.penup()
    rowFiveTriangles.forward(50)
    rowFiveTriangles.left(120)
    rowFiveTriangles.forward(50)
    rowFiveTriangles.pendown()
rowFiveTriangles.end_fill()
rowFiveTriangles.penup()

rowFourTriangles = turtle.Turtle()
rowFourTriangles.hideturtle()
rowFourTriangles.speed(0)
rowFourTriangles.fillcolor(colorSelector(0))
rowFourTriangles.penup()
rowFourTriangles.goto(-300, 0)
rowFourTriangles.left(60)
rowFourTriangles.forward(100)
rowFourTriangles.right(60)
rowFourTriangles.pendown()
rowFourTriangles.begin_fill()
for x in range(1, 5):
    rowFourTriangles.forward(50)
    rowFourTriangles.left(120)
    rowFourTriangles.forward(50)
    rowFourTriangles.left(120)
    rowFourTriangles.penup()
    rowFourTriangles.forward(50)
    rowFourTriangles.left(120)
    rowFourTriangles.forward(50)
    rowFourTriangles.pendown()
rowFourTriangles.end_fill()
rowFourTriangles.penup()

rowThreeTriangles = turtle.Turtle()
rowThreeTriangles.hideturtle()
rowThreeTriangles.speed(0)
rowThreeTriangles.fillcolor(colorSelector(0))
rowThreeTriangles.penup()
rowThreeTriangles.goto(-300, 0)
rowThreeTriangles.left(60)
rowThreeTriangles.forward(150)
rowThreeTriangles.right(60)
rowThreeTriangles.pendown()
rowThreeTriangles.begin_fill()
for x in range(1, 4):
    rowThreeTriangles.forward(50)
    rowThreeTriangles.left(120)
    rowThreeTriangles.forward(50)
    rowThreeTriangles.left(120)
    rowThreeTriangles.penup()
    rowThreeTriangles.forward(50)
    rowThreeTriangles.left(120)
    rowThreeTriangles.forward(50)
    rowThreeTriangles.pendown()
rowThreeTriangles.end_fill()
rowThreeTriangles.penup()

rowTwoTriangles = turtle.Turtle()
rowTwoTriangles.hideturtle()
rowTwoTriangles.speed(0)
rowTwoTriangles.fillcolor(colorSelector(0))
rowTwoTriangles.penup()
rowTwoTriangles.goto(-300, 0)
rowTwoTriangles.left(60)
rowTwoTriangles.forward(200)
rowTwoTriangles.right(60)
rowTwoTriangles.pendown()
rowTwoTriangles.begin_fill()
for x in range(1, 3):
    rowTwoTriangles.forward(50)
    rowTwoTriangles.left(120)
    rowTwoTriangles.forward(50)
    rowTwoTriangles.left(120)
    rowTwoTriangles.penup()
    rowTwoTriangles.forward(50)
    rowTwoTriangles.left(120)
    rowTwoTriangles.forward(50)
    rowTwoTriangles.pendown()
rowTwoTriangles.end_fill()
rowTwoTriangles.penup()

rowOneTriangles = turtle.Turtle()
rowOneTriangles.hideturtle()
rowOneTriangles.speed(0)
rowOneTriangles.fillcolor(colorSelector(0))
rowOneTriangles.penup()
rowOneTriangles.goto(-300, 0)
rowOneTriangles.left(60)
rowOneTriangles.forward(250)
rowOneTriangles.right(60)
rowOneTriangles.pendown()
rowOneTriangles.begin_fill()
for x in range(1, 2):
    rowOneTriangles.forward(50)
    rowOneTriangles.left(120)
    rowOneTriangles.forward(50)
    rowOneTriangles.left(120)
    rowOneTriangles.penup()
    rowOneTriangles.forward(50)
    rowOneTriangles.left(120)
    rowOneTriangles.forward(50)
    rowOneTriangles.pendown()
rowOneTriangles.end_fill()
rowOneTriangles.penup()

# this series of lists is used to report data following the run of the passes controlled by the input file
simLevels = [0, 0, 0, 0]
simTimesRun = [0, 0, 0, 0]
simMaxMoves = [0, 0, 0, 0]
simMaxDots = [0, 0, 0, 0]

# sim repeats 5 times.  1st pass runs the graphical representation
# passed 2 through 5 controlled by the input file\
# new gameboard is created each simRepeat
for simRepeat in range(1, 6):

    # loan numLevels and numTimesRan from the gameData list.  After these values saved into the reporting lists
    # pop off the first two values. On next run of sim, new values loaded into these variables
    numLevels = gameData[0]
    numTimesRan = gameData[1]

    # only retains the data from runs 2 through 5
    if firstGame == False:
        # the subscript adjust by 2 is due to this data is only recorded for sims 2 through 5 but the
        # list saving the data is 4 data points in each list.  adjust the subscript so game 2 aligns with
        # the 0 subscript in each reporting list
        simLevels[simRepeat - 2] = gameData[0]
        simTimesRun[simRepeat - 2] = gameData[1]

    # remove the data from the first two locations in gameData. allows 2nd pair to be used for next run of the for loop
    gameData.pop(1)
    gameData.pop(0)

    # determine number of nodes in the pyramid
    numNodes = int((int(numLevels) * (int(numLevels) + 1)) / 2)
    # create gameDotTrackerV2. uses the number of nodes to create the list.  add 1 because lists are index starting at 0
    gameDotTrackerV2 = [0] * (numNodes + 1)
    numVisits = 0

    # list declarations for recording statistics
    allMoves = [0] * int(numTimesRan)
    maxMoves = [0] * int(numTimesRan)

    # same game board creation as HW3.
    # only change was to bring into the for loop so that a new board is created each for loop

    # create gameBoard for Version 2 of pyramid. uses the number of nodes to create the list.  add 1 because lists are
    # index starting at 0
    gameBoardLocationV2 = [0, 0, 0, 0, 0] * (numNodes + 1)

    # game boards for both version 1 and version follow the same encoding rules
    #
    # gameBoardLocation contains the game data for each position on the board.
    # Encoding is as follows:
    # index 0 - dot counter
    # ended up not using the index 0 and opted for a separate list for the tracking of dots.  left in code for future use
    # index 1 - Valid Upper Left Movement
    # index 2 - Valid Lower Left Movement
    # index 3 - Valid Upper Right Movement
    # index 4 - Valid Lower Right Movement
    # index of gameBoardLocation corresponds to a location on the pyramid.
    # Example: gameBoardLocation[1] refers to position 1

    # generate gameBoardLocationV2 size

    # populate nodes

    # gameBoardLocationV2[0] not used for this project.  initializing as in version 1
    gameBoardLocationV2[0] = [0, None, None, None, None]
    # level 1 and  level 2 are required. setting these as special cases.  they will not generate automatically
    # same values as in version 1

    for level in range(1, (int(numLevels) + 1)):
        # levels 1 and 2 are special cases and declared implicitly
        if level == 1:
            gameBoardLocationV2[1] = [0, None, 2, None, 3]  # dot count starts at 0, valid moves are lower left, lower right

        if level == 2:
            gameBoardLocationV2[2] = [0, None, 4, 1, 5]
            gameBoardLocationV2[3] = [0, 1, 5, None, 6]

        # generates the nodes for all the rows in the game board that are not row 1, 2 or the terminating row
        if level >= 3 and level < int(numLevels):

            # determine the rightMostNode
            rightMostNode = int((int(level) * (int(level) + 1) / 2))
            # determine the leftMostNode
            leftMostNode = int(rightMostNode) - (int(level) - 1)

            # populate right most node's valid locations into the list
            gameBoardLocationV2[rightMostNode] = [0, rightMostNode - int(level), rightMostNode + int(level), None,
                                                  rightMostNode + int(level) + 1]

            # populate left most node's valid location into the list
            gameBoardLocationV2[leftMostNode] = [0, None, leftMostNode + int(level), leftMostNode - int(level) + 1,
                                                 leftMostNode + int(level) + 1]

            # purpose of the following for loop is to generate the internal nodes and the valid moves for each of the
            # internal nodes.  start at the left most node and continue to the right most node
            # skips the calculation for left and right most nodes as they are defined as special cases
            # results validated against the version 1 of the hard encoded list from HW 1
            y = leftMostNode
            for internalNode in range(leftMostNode, rightMostNode + 1):
                if internalNode != leftMostNode and internalNode != rightMostNode:
                    gameBoardLocationV2[internalNode] = [0, internalNode - int(level), internalNode + int(level), internalNode - int(level) + 1,
                                              internalNode + int(level) + 1]

        if level == int(numLevels):

            # determine the rightMostNode
            rightMostNode = int((int(numLevels) * (int(numLevels) + 1) / 2))
            # print("right most node is: " + str(rightMostNode))
            # determine the leftMostNode
            leftMostNode = int(rightMostNode) - (int(numLevels) - 1)
            # print("Left most node is: " + str(leftMostNode))

            # populate valid moves in the rightMostNode and leftMostNode
            gameBoardLocationV2[rightMostNode] = [0, rightMostNode - int(numLevels), None, None, None]
            gameBoardLocationV2[leftMostNode] = [0, None, None, leftMostNode - int(numLevels) + 1, None]

            # begin building internal nodes at the leftMostNode
            internalNode = leftMostNode
            for internalNode in range(leftMostNode, rightMostNode + 1):
                if internalNode != leftMostNode and internalNode != rightMostNode:
                    gameBoardLocationV2[internalNode] = [0, internalNode - int(numLevels), None, internalNode - int(numLevels) + 1, None]

    # this code used to validate gameboard generation
    # for z in range(1, int(numNodes) + 1):
    #    print("Location: " + str(z) + " is " + str(gameBoardLocationV2[z]))

    '''
    left this code so i could validate the results of the generated lists.  the above code if ran with 6 levels generates 
    identical list to the below encoding
    
    # gameBoardLocation encoding
    gameBoardLocation[0] = [0, None, None, None, None]  # unused for this project
    gameBoardLocation[1] = [0, None, 2, None, 3]  # dot count starts at 0, valid moves are lower left, lower right
    gameBoardLocation[2] = [0, None, 4, 1, 5]
    gameBoardLocation[3] = [0, 1, 5, None, 6]
    gameBoardLocation[4] = [0, None, 7, 2, 8]
    gameBoardLocation[5] = [0, 2, 8, 3, 9]
    gameBoardLocation[6] = [0, 3, 9, None, 10]
    gameBoardLocation[7] = [0, None, 11, 4, 12]
    gameBoardLocation[8] = [0, 4, 12, 5, 13]
    gameBoardLocation[9] = [0, 5, 13, 6, 14]
    gameBoardLocation[10] = [0, 6, 14, None, 15]
    gameBoardLocation[11] = [0, None, 16, 7, 17]
    gameBoardLocation[12] = [0, 7, 17, 8, 18]
    gameBoardLocation[13] = [0, 8, 18, 9, 19]
    gameBoardLocation[14] = [0, 9, 19, 10, 20]
    gameBoardLocation[15] = [0, 10, 20, None, 21]
    gameBoardLocation[16] = [0, None, None, 11, None]
    gameBoardLocation[17] = [0, 11, None, 12, None]
    gameBoardLocation[18] = [0, 12, None, 13, None]
    gameBoardLocation[19] = [0, 13, None, 14, None]
    gameBoardLocation[20] = [0, 14, None, 15, None]
    gameBoardLocation[21] = [0, 15, None, None, None]
    # end encoding of gameboard V1
    '''


    # sim will repeat based on repeat factor supplied in the input file
    # only addition from HW 3 was to add the controls for colorNode if during the first game
    for runTimes in range(1, int(numTimesRan) + 1):
        # stillPlaying controls if the game is continuing to play.  Once all locations have been visited once, stillPlaying
        # will change to false and terminate the game
        stillPlaying = True

        gameDotTrackerV2.clear()  # clear out the current dotTracker to make it ready for next run of the sim

        # i start the 0 location as 1 so that the game can end if no 0s are found in the list.  this requires an adjustment of
        # -1 to the game statistics
        gameDotTrackerV2 = [0] * (numNodes + 1)
        gameDotTrackerV2[0] = 1
        # i opted to count the start of the game as a visit to location 1.  remove this initialization to not have the start
        # counted as a visit
        gameDotTrackerV2[1] = 1
        diceRoll = 0
        currentLocation = 1  # game starts location 1.
        if verbose == True:
            print("Game Location: " + str(currentLocation), end='')
            # outputFile.write("Game Location: " + str(currentLocation))

        while stillPlaying:

            # simulate a dice rolling by generating random value 1 to 4. Each value represents a direction to move as follows:
            # 1 = Upper Left, 2 = Lower Left, 3 = Upper Right, 4 = Lower Right
            diceRoll = random.randint(1, 4)
            # added this sleep so I could watch the program execute instead of instantly complete.
            # adjust this value to slow/down speed up the simulation
            # commented out as not a requirement of this assignment.  uncomment out to restore delay
            # time.sleep(0.015)

        # this section checks to see if the location selected by the dice roll is valid.  if so, updates the visit counter and
        # changes current location to the new location on the gameboard.
        # if the move is not valid, increments the counter for the currentlocation
            if gameBoardLocationV2[currentLocation][diceRoll] is not None:
                currentLocation = gameBoardLocationV2[currentLocation][diceRoll]
                if firstGame == True:
                    numVisits = -1
                    colorNode(currentLocation)
                # for progam efficieny, commenting out the dottracking in the location tuple since this isn't used in the final
                # calculations.  left for future use.
                # gameBoardLocation[currentLocation][0] += 1
                gameDotTrackerV2[currentLocation] += 1
                if firstGame == True:
                    numVisits = gameDotTrackerV2[currentLocation]
                    colorNode(currentLocation)

                if verbose == True:
                    print(",", end='')
                    print(str(currentLocation), end='')
                    # outputFile.write("," + str(currentLocation))
                # commented code below allows for more verbose description of what is occurring in game
                # print("Move valid.  New Location is " + str(currentLocation) + ". Incrementing count. Location " + str(currentLocation) +
                # " has been visited " + str(gameBoardLocation[currentLocation][0]) + " times")
            else:
                # commented code below allows for more verbose description of what is occurring in game
                # print("Unable to move.  Incrementing count for location " + str(currentLocation))
                if firstGame == True:
                    numVisits = -1
                    colorNode(currentLocation)
                currentLocation = currentLocation
                gameDotTrackerV2[currentLocation] += 1
                if firstGame == True:
                    numVisits = gameDotTrackerV2[currentLocation]
                    colorNode(currentLocation)

                # for progam efficieny, commenting out the dottracking in the location tuple since this isn't used in the final
                # calculations.  left for future use.
                # gameBoardLocation[currentLocation][0] += 1
                if verbose == True:
                    print(",", end='')
                    print(str(currentLocation), end='')
                    # outputFile.write("," + str(currentLocation))

        # this code checks to see if 0 does not exist in the gameDotTracker array.  If not, stillPlaying changes to False and the game ends
            if 0 not in gameDotTrackerV2:
                stillPlaying = False
                if verbose == True:
                    print(".")
                    # outputFile.write(".\n")

        '''
        print("\nGame Statistics for game: " + str(runTimes))
        outputFile.write("\nGame Statistics for game: " + str(runTimes) + "\n\n")
        '''

        # need to adjust off 1 move from totalMoves in each calculation due to the unused element 0 in gameDotTracker being
        # initalized to 1.

        # stores the total moves for each run of the sim
        totalMoves: int = sum(gameDotTrackerV2)

        # need to adjust off 1 move from each recorded moves due to the setting of the 0 index to 1
        allMoves[runTimes - 1] = (totalMoves - 1)

        # find the maximum of dots on any one location
        maxDots = max(gameDotTrackerV2)
        maxMoves[runTimes - 1] = maxDots

        # this turtle draws the report for the graphical representation of the first pass of the sim.
        # only draws first pass
        if firstGame == True:
            textTurtle = turtle.Turtle()
            textTurtle.penup()
            textTurtle.hideturtle()
            textTurtle.goto(-300, -50)
            textTurtle.write("Total moves to complete the game: " + str(totalMoves - 1))
            textTurtle.goto(-300, -70)
            textTurtle.write("Average visits per location: " + str((totalMoves - 1)/21))
            textTurtle.goto(-300, -90)
            textTurtle.write("Maximum visits to any one location: " + str(maxDots))
        '''
        print("Total moves to complete the game: " + str(totalMoves - 1))
        outputFile.write("Total moves to complete the game: " + str(totalMoves - 1) + "\n")
        print("Average visits per location: " + str((totalMoves - 1)/21))
        outputFile.write("Average visits per location: " + str((totalMoves - 1)/21) + "\n")

        print("Maximum visits to any one location: " + str(maxDots) + "\n\n")
        outputFile.write("Maximum visits to any one location: " + str(maxDots) + "\n\n\n")
        '''

    # retains only the data from passes 2 through 5
    if firstGame == False:
        # the subscript adjust by 2 is due to this data is only recorded for sims 2 through 5 but the
        # list saving the data is 4 data points in each list.  adjust the subscript so game 2 aligns with
        # the 0 subscript in each reporting list
        simMaxMoves[simRepeat - 2] = sum(allMoves)
        simMaxDots[simRepeat - 2] = max(maxMoves)
        # print(simMaxMoves)
        # print(simMaxDots)

    # change the firstGame flag to false.  This turns off the features associated with graphical representation
    firstGame = False

'''
# Grand Total Statistics
print("Total Simulation Statistics\n")
outputFile.write("Total Simulation Statistics\n")

grandTotalMoves: int = sum(allMoves)
print("Minimum moves required to a complete a sim was: " + str(min(allMoves)))
outputFile.write("Minimum moves required to complete a sim was: " + str(min(allMoves)) + "\n")

print("Maximum moves required to complete a sim was: " + str(max(allMoves)))
outputFile.write("Maximum moves required to complete a sim was: " + str(max(allMoves)) + "\n")


# print("Grand total of all moves: " + str(grandTotalMoves))
# outputFile.write("Grand total of all moves to complete the sim: " + str(grandTotalMoves) + "\n")
averageMovesToCompleteTheSims = grandTotalMoves / int(numTimesRan)
print("Average number of moves to complete each sim: " + str(averageMovesToCompleteTheSims))
outputFile.write("Average number of moves to complete each sim: " + str(averageMovesToCompleteTheSims) + "\n")

print("Minimum max moves is: " + str(min(maxMoves)))
outputFile.write("Minimum max moves is: " + str(min(maxMoves)) + "\n")

print("Maximum max moves is: " + str(max(maxMoves)))
outputFile.write("Maximum max moves is: " + str(max(maxMoves)) + "\n")

averageMaxMoves = (sum(maxMoves) / int(numTimesRan))
print("Average number of max moves: " + str(averageMaxMoves))
outputFile.write("Average number of max moves: " + str(averageMaxMoves) + "\n")
'''

# prints the chart for sim data from passes 2 through 5
print("Data for Sims from Input File\n")
print("|\t\t\t|Run 1\t\t|Run 2\t\t|Run 3\t\t|Run 4\t\t|")
print("|Levels\t\t|" + "\t" + str(simLevels[0]) + "\t\t|\t" + str(simLevels[1]) + "\t\t|\t" + str(simLevels[2]) + "\t\t|\t" + str(simLevels[3]) + "\t\t|")
print("|Runs\t\t|" + "\t" + str(simTimesRun[0]) + "\t\t|\t" + str(simTimesRun[1]) + "\t\t|\t" + str(simTimesRun[2]) + "\t\t|\t" + str(simTimesRun[3]) + "\t\t|")
print("|Moves:\t\t|" + "\t" + str(simMaxMoves[0]) + "\t|\t" + str(simMaxMoves[1]) + "\t|\t" + str(simMaxMoves[2]) + "\t\t|\t" + str(simMaxMoves[3]) + "\t|")
print("|Max Dots:\t| " + "\t" + str(simMaxDots[0]) + "\t\t|\t" + str(simMaxDots[1]) + "\t\t|\t" + str(simMaxDots[2]) + "\t\t|\t" + str(simMaxDots[3]) + "\t\t|")
# close the file being written
# outputFile.close()

turtle.done()

# testing
# colorNode  slows down sim running.  comment out in order to speed up testing.  final runs turned back on
# used defined dice rolls to determine if currentlocation changed to expected location
# displayed gameDotTracker to be able to confirm dot summing and max dots to verify index
# git used for version control.
# tested upper and lower boundries for number of levels and number of times to run sim
# tested to validate user input is an int
# validated the generation of levels against original encoding.
# tested verbose on and off.  results as expected
# hard time testing final numbers for passes 2 through 5.  seems to make sense based on previous versions

# feature consideration - change the way the active node works by drawing a new triangle over the previous and then
# resetting it once its no longer active instead of redrawing each node